# <center>Week 2 Assignments</center>

# Tasks 

- [ ] Array Sum 
- [ ] Vector Dot
- [ ] Vector Add 

# Observations and Measures

## Array Sum
My algorithm is basically calculate the the start index (my_first_i) and the last index (my_last_i) of each process and then add them together as localsum. I also printed out the my_first_i and the my_last_i so that it would be more clear to see which index each process is processing. I did not touch anything in the MPI_Send and MPI_Recv since it would work in my case since in the if else statement of MPI_Send and MPI_Recv, it just added all of the localsum as globalsum and print it out.
The result printed out is the same as the one before any changes (using the cyclically algorithm one).

| processor |  p1   | p2  | p3   | p4 | 
|----------|:------------:|------:|---|---|
| 1| 1057 |  -- | --   | --|
| 2| 541 |  516 | --   | --|
| 3 | 350 |  368 | 339   | --|
| 4 | 281 |  291 | 250   | 235|

## Vector Dot 
So I mainly just combine the vector.c and the array_sum.c file together to get this. I keep the part of MPI from array_sum one; and use the counting time and vector allocate in vector code. Also, to check what number is multiplying in the vector, you can just uncomment the block 93-96.

For observation of run time:
* vector size = 10

| processor |  time (ms)  | speedup  |
|----------|:------------:|------:|
| 1| 0.026000 |  1 |
| 2| 0.069000 |  0.377 | 
| 3 | 0.341000 |  0.076 | 
| 4 | 0.086000 |  0.302 | 

For observation of run time:
* vector size = 10000

| processor |  time (ms)  | speedup  |
|----------|:------------:|------:|
| 1| 19.262 |  1 |
| 2| 19.806 |  0.973 | 
| 3 | 20.903 |  0.921 | 
| 4 | 22.011 |  0.875 | 

For observation of run time:
* vector size = 1000000

| processor |  time (ms)  | speedup  |
|----------|:------------:|------:|
| 1| 1947.41 |  1 |
| 2| 1986.498 |  0.980 | 
| 3 | 2082.822 |  0.935 | 
| 4 | 2127.554 |  0.915 | 


##  Vector Add
For now, it is not able to run the expected result. It seems like not able to actually receive from processors other than the first one. But as I tried to print out the message each processor execute, they are able to add by their own but just not able to receive in processor 0. I would figure it out asap.

Just fixed, it was not working because 1. I do the allocate for local vector before the loop of receiving the local vectors so it is always getting one partial solution. 2. the counter for adding into the vector is not right and I fix it with adding a condition of if (it's receiving 0.00000){ignore}, which is not a good way since 0.00000 might be generated by random. However, I did not find any other ways to solve it.


For observation of run time:
* vector size = 100

| processor |  time (ms)  | speedup  |
|----------|:------------:|------:|
| 1| 0.002 |  1 |
| 2| 0.037 |  0.054 | 
| 3 | 0.072 |  0.028 | 
| 4 | 0.079 |  0.025 | 

For observation of run time:
* vector size = 10000

| processor |  time (ms)  | speedup  |
|----------|:------------:|------:|
| 1| 0.121 |  1 |
| 2| 0.373 |  0.324 | 
| 3 | 0.56 |  0.216 | 
| 4 | 0.578 |  0.209 | 

For observation of run time:
* vector size = 1000000

| processor |  time (ms)  | speedup  |
|----------|:------------:|------:|
| 1| 16.136 |  1 |
| 2| 31.253 |  0.516 | 
| 3 | 41.28 |  0.391 | 
| 4 | 52.841 |  0.305 | 

